"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseHead = exports.bufferSplit = exports.bufferIndexOf = exports.parseFromReadableStream = exports.parseMultipart = void 0;
const stream_1 = require("stream");
const headSeparator = Buffer.from('\r\n\r\n');
const parseMultipart = async (body, boundary, uploadConfig) => {
    if (typeof body === 'string') {
        if (uploadConfig.base64) {
            body = Buffer.from(body, 'base64');
        }
        else {
            body = Buffer.from(body);
        }
    }
    const bufferSeparator = Buffer.from('\r\n--' + boundary);
    const fields = {};
    const files = [];
    (0, exports.bufferSplit)(body, bufferSeparator).forEach(buf => {
        const [headerBuf, data] = (0, exports.bufferSplit)(buf, headSeparator, 2);
        const head = (0, exports.parseHead)(headerBuf);
        if (!head['content-disposition']) {
            return;
        }
        if (!head['content-disposition'].filename) {
            if (head['content-disposition'].name) {
                fields[head['content-disposition'].name] = data.toString();
            }
            return;
        }
        files.push({
            filename: head['content-disposition'].filename,
            data,
            fieldName: head['content-disposition'].name,
            mimeType: head['content-type'],
        });
    });
    return {
        files,
        fields,
    };
};
exports.parseMultipart = parseMultipart;
const pre = Buffer.from('\r\n');
const parseFromReadableStream = (readStream, boundary) => {
    const bufferSeparator = Buffer.from(`\r\n--${boundary}`);
    const fields = {};
    const fileInfo = {
        filename: '',
        data: null,
        fieldName: '',
        mimeType: '',
    };
    const emptyBuf = Buffer.alloc(0);
    // 上一次遗留的 chunk
    let lastChunk = emptyBuf;
    // 前一个chunk的后缀
    let preChunk = emptyBuf;
    let isTransformFileData = false;
    let isTransformFileDataEnd = false;
    // let isEnd = false;
    let isFirst = true;
    let allChuns = Buffer.alloc(0);
    return new Promise(resolve => {
        fileInfo.data = new stream_1.Transform({
            highWaterMark: 1000,
            transform(chunk, encoding, callback) {
                if (isFirst) {
                    chunk = Buffer.concat([pre, chunk]);
                    isFirst = false;
                }
                // 已经结束了
                if (isTransformFileDataEnd) {
                    return callback(null, null);
                }
                // 正在传输中的话
                if (isTransformFileData) {
                    const newPreChunk = Buffer.concat([preChunk, chunk]);
                    const newBlockIndex = (0, exports.bufferIndexOf)(newPreChunk, bufferSeparator);
                    // 存在新的块则代表已经结束了
                    if (newBlockIndex !== -1) {
                        // 上一个块的最后一部分数据，需要追加写入
                        const lastDataBlock = newPreChunk.slice(preChunk.length, newBlockIndex);
                        isTransformFileDataEnd = true;
                        callback(null, lastDataBlock);
                        return;
                    }
                    // 块尚未结束，则继续写入
                    callback(null, chunk);
                    preChunk = newPreChunk.slice(-bufferSeparator.length);
                    return;
                }
                // 未在传输过程中
                allChuns = Buffer.concat([allChuns, chunk]);
                const splitAllChuns = (0, exports.bufferSplit)(allChuns, bufferSeparator);
                for (let chunkIndex = 0; chunkIndex < splitAllChuns.length; chunkIndex++) {
                    const [headerBuf, data] = (0, exports.bufferSplit)(splitAllChuns[chunkIndex], headSeparator);
                    const head = (0, exports.parseHead)(headerBuf);
                    if (!head['content-disposition']) {
                        continue;
                    }
                    if (!head['content-disposition'].filename) {
                        if (head['content-disposition'].name) {
                            fields[head['content-disposition'].name] = data.toString();
                        }
                        continue;
                    }
                    // 这里就是找到了 file 的段，如果没有数据，则需要继续等待
                    if (!data.length) {
                        continue;
                    }
                    fileInfo.filename = head['content-disposition'].filename;
                    fileInfo.fieldName = head['content-disposition'].name;
                    fileInfo.mimeType = head['content-type'];
                    isTransformFileData = true;
                    lastChunk = data;
                    allChuns = emptyBuf;
                    this.pause();
                    resolve({ fileInfo, fields });
                    break;
                }
                callback(null, lastChunk);
            },
        });
        readStream.pipe(fileInfo.data);
        const empty = new stream_1.Writable();
        empty._write = function (chunk, encoding, cb) {
            cb();
        };
        fileInfo.data.pipe(empty);
    });
};
exports.parseFromReadableStream = parseFromReadableStream;
// search buffer index
const bufferIndexOf = (buffer, search, offset) => {
    return buffer.indexOf(search, offset);
};
exports.bufferIndexOf = bufferIndexOf;
// split buffer to buffer list
const bufferSplit = (buffer, separator, limit) => {
    let index = 0;
    const result = [];
    let find = (0, exports.bufferIndexOf)(buffer, separator, index);
    while (find !== -1) {
        result.push(buffer.slice(index, find));
        index = find + separator.length;
        if (limit && result.length + 1 === limit) {
            break;
        }
        find = (0, exports.bufferIndexOf)(buffer, separator, index);
    }
    result.push(buffer.slice(index));
    return result;
};
exports.bufferSplit = bufferSplit;
const headReg = /^([^:]+):[ \t]?(.+)?$/;
const parseHead = (headBuf) => {
    const head = {};
    const headStrList = headBuf.toString().split('\r\n');
    for (const headStr of headStrList) {
        const matched = headReg.exec(headStr);
        if (!matched) {
            continue;
        }
        const name = matched[1].toLowerCase();
        const value = matched[2]
            ? matched[2].replace(/&#(\d+);/g, (origin, code) => {
                try {
                    return String.fromCharCode(parseInt(code));
                }
                catch (_a) {
                    return origin;
                }
            })
            : '';
        if (name === 'content-disposition') {
            const headCol = {};
            value.split(/;\s+/).forEach((kv) => {
                const [k, v] = kv.split('=');
                headCol[k] = v ? v.replace(/^"/, '').replace(/"$/, '') : v !== null && v !== void 0 ? v : true;
            });
            head[name] = headCol;
        }
        else {
            head[name] = value;
        }
    }
    return head;
};
exports.parseHead = parseHead;
//# sourceMappingURL=parse.js.map