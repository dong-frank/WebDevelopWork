"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.formatExt = exports.ensureDir = exports.checkExists = exports.stopAutoRemoveUploadTmpFile = exports.autoRemoveUploadTmpFile = void 0;
const fs_1 = require("fs");
const path_1 = require("path");
const { readdir, access, stat, unlink, mkdir } = fs_1.promises;
let autoRemoveUploadTmpFileTimeoutHandler;
let autoRemoveUploadTmpFilePromise;
const autoRemoveUploadTmpFile = async (tmpDir, cleanTimeout) => {
    clearTimeout(autoRemoveUploadTmpFileTimeoutHandler);
    let waitTime = cleanTimeout / 3;
    if (waitTime < 1000) {
        waitTime = 1000;
    }
    if (autoRemoveUploadTmpFilePromise) {
        const exists = await (0, exports.checkExists)(tmpDir);
        if (exists) {
            const paths = await readdir(tmpDir);
            const now = Date.now();
            await Promise.all(paths.map(async (path) => {
                const filePath = (0, path_1.join)(tmpDir, path);
                try {
                    const statInfo = await stat(filePath);
                    if (statInfo.isFile() && now - statInfo.ctimeMs > cleanTimeout) {
                        await unlink(filePath);
                    }
                }
                catch (_a) {
                    return false;
                }
            }));
        }
    }
    autoRemoveUploadTmpFileTimeoutHandler = setTimeout(() => {
        autoRemoveUploadTmpFilePromise = (0, exports.autoRemoveUploadTmpFile)(tmpDir, cleanTimeout);
    }, waitTime);
};
exports.autoRemoveUploadTmpFile = autoRemoveUploadTmpFile;
const stopAutoRemoveUploadTmpFile = async () => {
    if (autoRemoveUploadTmpFilePromise) {
        await autoRemoveUploadTmpFilePromise;
        autoRemoveUploadTmpFilePromise = null;
    }
    clearTimeout(autoRemoveUploadTmpFileTimeoutHandler);
};
exports.stopAutoRemoveUploadTmpFile = stopAutoRemoveUploadTmpFile;
const checkExists = async (path) => {
    try {
        await access(path, fs_1.constants.W_OK | fs_1.constants.R_OK);
        return true;
    }
    catch (_a) {
        return false;
    }
};
exports.checkExists = checkExists;
const ensureDir = async (dirPath) => {
    const isExists = await (0, exports.checkExists)(dirPath);
    if (isExists) {
        return true;
    }
    try {
        await mkdir(dirPath, { recursive: true });
        return true;
    }
    catch (_a) {
        return false;
    }
};
exports.ensureDir = ensureDir;
const formatExt = (ext) => {
    return Buffer.from(ext.toLowerCase())
        .filter(ext => {
        // .
        if (ext === 0x2e) {
            return true;
        }
        // 0-9
        if (ext >= 0x30 && ext <= 0x39) {
            return true;
        }
        // a-z
        if (ext >= 0x61 && ext <= 0x7a) {
            return true;
        }
        return false;
    })
        .toString();
};
exports.formatExt = formatExt;
//# sourceMappingURL=utils.js.map