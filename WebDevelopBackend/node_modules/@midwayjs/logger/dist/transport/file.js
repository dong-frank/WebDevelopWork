"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.JSONTransport = exports.ErrorTransport = exports.FileTransport = void 0;
const transport_1 = require("./transport");
const fileStreamRotator_1 = require("./fileStreamRotator");
const path = require("path");
const zlib = require("zlib");
const fs = require("fs");
const util_1 = require("../util");
const hash_1 = require("../util/hash");
const safe_stable_stringify_1 = require("safe-stable-stringify");
class FileTransport extends transport_1.Transport {
    constructor(options = {}) {
        super(options);
        this.options = options;
        this.bufSize = 0;
        this.buf = [];
        if (this.options.bufferWrite) {
            this.options.bufferMaxLength = this.options.bufferMaxLength || 1000;
            this.options.bufferFlushInterval =
                this.options.bufferFlushInterval || 1000;
            this.timer = this.createInterval();
        }
        if (!(0, util_1.isValidFileName)(this.options.fileLogName) ||
            !(0, util_1.isValidDirName)(this.options.dir)) {
            throw new Error('Your path or filename contain an invalid character.');
        }
        const defaultStreamOptions = {
            frequency: 'custom',
            dateFormat: 'YYYY-MM-DD',
            endStream: true,
            fileOptions: { flags: 'a' },
            utc: false,
            extension: '',
            createSymlink: !(0, util_1.isWin32)(), // windows 下不生成软链
            maxFiles: '7d',
            zippedArchive: false,
        };
        if (!this.options.auditFileDir) {
            options.auditFileDir = this.options.dir;
        }
        if (!path.isAbsolute(this.options.auditFileDir)) {
            options.auditFileDir = path.join(this.options.dir, options.auditFileDir);
        }
        this.logStream = fileStreamRotator_1.FileStreamRotatorManager.getStream({
            ...defaultStreamOptions,
            filename: path.join(this.options.dir, this.options.fileLogName),
            size: (0, util_1.getMaxSize)(this.options.maxSize || '200m'),
            symlinkName: this.options.fileLogName,
            auditFile: path.join(options.auditFileDir, '.' + (0, hash_1.hash)(this.options) + '-audit.json'),
            ...options,
        });
        this.logStream.on('logRemoved', params => {
            if (options.zippedArchive) {
                const gzName = params.name + '.gz';
                if (fs.existsSync(gzName)) {
                    try {
                        fs.unlinkSync(gzName);
                    }
                    catch (_err) {
                        // 尝试删除文件时可能会有些报错，比如权限问题，输出到 stderr 中
                        console.error(_err);
                    }
                    return;
                }
            }
        });
        if (options.zippedArchive) {
            this.logStream.on('rotate', oldFile => {
                const oldFileExist = fs.existsSync(oldFile);
                const gzExist = fs.existsSync(oldFile + '.gz');
                if (!oldFileExist || gzExist) {
                    return;
                }
                const gzip = zlib.createGzip();
                const inp = fs.createReadStream(oldFile);
                const out = fs.createWriteStream(oldFile + '.gz');
                inp
                    .pipe(gzip)
                    .pipe(out)
                    .on('finish', () => {
                    if (fs.existsSync(oldFile)) {
                        fs.unlinkSync(oldFile);
                    }
                });
            });
        }
    }
    log(level, meta, ...args) {
        if (!(0, util_1.isEnableLevel)(level, this.options.level)) {
            return;
        }
        let buf = this.format(level, meta, args);
        buf += this.options.eol;
        if (this.options.bufferWrite) {
            this.bufSize += buf.length;
            this.buf.push(buf);
            if (this.buf.length > this.options.bufferMaxLength) {
                this.flush();
            }
        }
        else {
            this.logStream.write(buf);
        }
    }
    /**
     * close stream
     */
    close() {
        if (this.options.bufferWrite) {
            if (this.buf && this.buf.length > 0) {
                this.flush();
            }
            if (this.timer) {
                clearInterval(this.timer);
                this.timer = null;
            }
        }
        if (this.logStream) {
            fileStreamRotator_1.FileStreamRotatorManager.close(this.logStream);
            // 处理重复调用 close
            this.logStream = null;
        }
    }
    flush() {
        if (this.buf.length > 0 && this.writable) {
            this.logStream.write(this.buf.join(''));
            this.buf = [];
            this.bufSize = 0;
        }
    }
    /**
     * create interval to flush log into file
     */
    createInterval() {
        return setInterval(() => this.flush(), this.options.bufferFlushInterval);
    }
    get writable() {
        return this.logStream && this.logStream.canWrite();
    }
}
exports.FileTransport = FileTransport;
class ErrorTransport extends FileTransport {
    constructor(options) {
        options.level = 'error';
        super(options);
    }
}
exports.ErrorTransport = ErrorTransport;
class JSONTransport extends FileTransport {
    log(level, meta, ...args) {
        if (!(0, util_1.isEnableLevel)(level, this.options.level)) {
            return;
        }
        let buf = this.format(level, meta, args);
        if (typeof buf === 'string' || Buffer.isBuffer(buf)) {
            buf = (0, safe_stable_stringify_1.stringify)({
                message: buf.toString(),
            });
        }
        else {
            buf = (0, safe_stable_stringify_1.stringify)(buf);
        }
        buf += this.options.eol;
        if (this.options.bufferWrite) {
            this.bufSize += buf.length;
            this.buf.push(buf);
            if (this.buf.length > this.options.bufferMaxLength) {
                this.flush();
            }
        }
        else {
            this.logStream.write(buf);
        }
    }
}
exports.JSONTransport = JSONTransport;
//# sourceMappingURL=file.js.map