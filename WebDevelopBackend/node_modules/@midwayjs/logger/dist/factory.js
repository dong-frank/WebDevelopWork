"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LoggerFactory = void 0;
const logger_1 = require("./logger");
const util = require("util");
const path_1 = require("path");
const util_1 = require("./util");
const debug = util.debuglog('midway:debug');
class LoggerFactory extends Map {
    constructor(factoryOptions = {}) {
        super();
        this.factoryOptions = factoryOptions;
    }
    createLogger(name, options) {
        if (!this.has(name)) {
            debug('[logger]: Create logger "%s" with options %j', name, options);
            const logger = new logger_1.MidwayLogger(Object.assign(options, this.factoryOptions));
            this.addLogger(name, logger);
            return logger;
        }
        return this.getLogger(name);
    }
    addLogger(name, logger, errorWhenReplace = true) {
        if (!errorWhenReplace || !this.has(name)) {
            // 同一个实例就不需要再添加了
            if (this.get(name) !== logger) {
                if (logger['onClose']) {
                    logger['onClose'](() => {
                        this.delete(name);
                    });
                }
                if (logger['on']) {
                    logger.on('close', () => this.delete(name));
                }
                this.set(name, logger);
            }
        }
        else {
            throw new Error(`logger id ${name} has duplicate`);
        }
        return this.get(name);
    }
    getLogger(name) {
        return this.get(name);
    }
    removeLogger(name) {
        const logger = this.get(name);
        logger === null || logger === void 0 ? void 0 : logger['close']();
        this.delete(name);
    }
    get(name) {
        return super.get(name);
    }
    /**
     * Closes a `Logger` instance with the specified `name` if it exists.
     * If no `name` is supplied then all Loggers are closed.
     * @param {?string} name - The id of the Logger instance to close.
     * @returns {undefined}
     */
    close(name) {
        if (name) {
            return this.removeLogger(name);
        }
        Array.from(this.keys()).forEach(key => this.removeLogger(key));
    }
    getDefaultMidwayLoggerConfig(appInfo) {
        var _a;
        const isDevelopment = (0, util_1.isDevelopmentEnvironment)(appInfo.env);
        const logRoot = (_a = process.env['MIDWAY_LOGGER_WRITEABLE_DIR']) !== null && _a !== void 0 ? _a : appInfo.root;
        if (!logRoot) {
            throw new Error('Midway Logger requires a root path during initialization, but it was provided empty. Please set it manually in the "logger.default.dir" configuration.');
        }
        return {
            midwayLogger: {
                default: {
                    fileLogName: 'midway-app.log',
                    errorLogName: 'common-error.log',
                    dir: (0, path_1.join)(logRoot, 'logs', appInfo.name),
                    auditFileDir: '.audit',
                    transports: {
                        console: isDevelopment
                            ? {
                                autoColors: isDevelopment,
                            }
                            : false,
                        file: {
                            bufferWrite: !isDevelopment,
                        },
                        error: {
                            bufferWrite: !isDevelopment,
                        },
                    },
                },
                clients: {
                    coreLogger: {
                        fileLogName: 'midway-core.log',
                    },
                    appLogger: {},
                },
            },
        };
    }
    createContextLogger(ctx, appLogger, options = {}) {
        return appLogger.createContextLogger(ctx, options);
    }
}
exports.LoggerFactory = LoggerFactory;
//# sourceMappingURL=factory.js.map